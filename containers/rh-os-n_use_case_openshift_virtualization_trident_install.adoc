---
sidebar: sidebar 
permalink: containers/rh-os-n_use_case_openshift_virtualization_trident_install.html 
keywords: OpenShift, OCP, Trident, Trident protect, NetApp ONTAP, Red Hat OpenShift, OpenShift Virtualization, Red Hat OpenShift Virtualization 
summary: Virtualização OpenShift da Red Hat com NetApp ONTAP 
---
= Instalação do Trident e criação de objetos Trident.
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
Esta seção detalha como instalar o Trident para preparar os nós de trabalho para acesso a bloco. Ele fornece instruções passo a passo para criar os objetos de classe de storage e back-end do Trident. O objeto de back-end do Trident inclui todos os detalhes necessários para se conectar ao sistema de storage ONTAP de back-end e provisionar dinamicamente volumes no ONTAP para o protocolo especificado. O objeto da classe de storage permite que as aplicações de contêiner e as VMs solicitem o storage usando apenas o tipo e a capacidade, sem precisar de nenhuma conectividade e outros detalhes no back-end.


NOTE: Se você precisar criar VMs na virtualização OpenShift, o Trident deve ser instalado e os objetos de back-end e os objetos de classe de armazenamento devem ser criados no cluster OpenShift antes que a virtualização OpenShift seja instalada no cluster. A classe de armazenamento padrão e a classe de snapshot de volume padrão devem ser definidas para o armazenamento Trident e a classe de snapshot no cluster. Somente quando isso estiver configurado, a virtualização do OpenShift pode baixar imagens douradas e disponibilizá-las para criação de VM usando modelos.

**Instalação do Trident**

.Instalar o Trident usando o Operador certificado Red Hat
[%collapsible%open]
====
Nesta seção, são fornecidos detalhes sobre a instalação do Trident usando o Operador Trident certificado pela Red Hat. link:https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy.html["Consulte a documentação do Trident"] Para outras formas de instalar o Trident. Com o lançamento do Trident 25,02, os usuários do Trident no Red Hat OpenShift no local e na nuvem e serviços gerenciados como o serviço Red Hat OpenShift na AWS agora podem instalar o Trident usando o Operador certificado Trident no Hub do Operador. Isso é significativo para a comunidade de usuários do OpenShift, já que o Trident estava disponível anteriormente apenas como um operador comunitário.

A vantagem do operador Red Hat Certified Trident é que a base para o operador e seus contêineres é totalmente suportada pelo NetApp quando usado com o OpenShift (seja no local, na nuvem ou como um serviço gerenciado). Além disso, o NetApp Trident vem sem nenhum custo para o cliente, então tudo o que você precisa fazer é instalá-lo usando o operador certificado que foi verificado para funcionar perfeitamente com o Red Hat OpenShift e empacotado para facilitar o gerenciamento do ciclo de vida.

Para instalar o Trident usando o Operador, clique no Hub do Operador e selecione NetApp Trident certificado. Na página Instalar, a versão mais recente é selecionada por padrão. Clique em Instalar. image:rh-os-n_use_case_openshift_virtualization_trident_install_img1.png["cubo do operador"]

image:rh-os-n_use_case_openshift_virtualization_trident_install_img2.png["instale"]

Uma vez instalado o operador, clique em view operator e, em seguida, crie uma instância do Trident Orchestrator. Se quiser preparar os nós de trabalho para acesso ao armazenamento iSCSI, vá para a visualização yaml e modifique o parâmetro nodePrep adicionando iscsi.

image:rh-os-n_use_case_openshift_virtualization_trident_install_img3.png["adicionar iscsi para preparação de nó"]

Agora você deve ter todos os pods do Trident em execução no cluster. image:rh-os-n_use_case_openshift_virtualization_trident_install_img4.png["Trident instalado"]

Para verificar se as ferramentas iSCSI foram ativadas nos nós de trabalho do cluster OpenShift, faça login nos nós de trabalho e verifique se você vê o iscsid, multipathd ativo e as entradas no arquivo multipath.conf como mostrado.

image:rh-os-n_use_case_openshift_virtualization_trident_install_img5.png["iscsid running"]

image:rh-os-n_use_case_openshift_virtualization_trident_install_img6.png["corrida multipathd"]

image:rh-os-n_use_case_openshift_virtualization_trident_install_img7.png["ficheiro multipathconf em execução"]

====
**Configuração do Trident para cluster OpenShift on-premise**

.Classe de storage e back-end do Trident para nas
[%collapsible%open]
====
[source, yaml]
----
cat tbc-nas.yaml
apiVersion: v1
kind: Secret
metadata:
  name: tbc-nas-secret
type: Opaque
stringData:
  username: <cluster admin username>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: tbc-nas
spec:
  version: 1
  storageDriverName: ontap-nas
  managementLIF: <cluster management lif>
  backendName: tbc-nas
  svm: zoneb
  storagePrefix: testzoneb
  defaults:
    nameTemplate: "{{ .config.StoragePrefix }}_{{ .volume.Namespace }}_{{ .volume.RequestName }}"
  credentials:
    name: tbc-nas-secret
----
[source, yaml]
----
cat sc-nas.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-nas
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-nas"
  media: "ssd"
  provisioningType: "thin"
  snapshots: "true"
allowVolumeExpansion: true
----
====
.Backend Trident e classe de armazenamento para iSCSI
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-iscsi.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-tbc-ontap-iscsi-secret
type: Opaque
stringData:
  username: <cluster admin username>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: ontap-iscsi
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <management LIF>
  backendName: ontap-iscsi
  svm: <SVM name>
  credentials:
    name: backend-tbc-ontap-iscsi-secret
----
[source, yaml]
----
# cat sc-iscsi.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-iscsi
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
.Back-end e classe de storage do Trident para NVMe/TCP
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-nvme.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-tbc-ontap-nvme-secret
type: Opaque
stringData:
  username: <cluster admin password>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: backend-tbc-ontap-nvme
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <cluster management LIF>
  backendName: backend-tbc-ontap-nvme
  svm: <SVM name>
  credentials:
    name: backend-tbc-ontap-nvme-secret
----
[source, yaml]
----
# cat sc-nvme.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-nvme
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
.Classe de storage e back-end do Trident para FC
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-fc.yaml
apiVersion: v1
kind: Secret
metadata:
  name: tbc-fc-secret
type: Opaque
stringData:
  username: <cluster admin password>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: tbc-fc
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <cluster mgmt lif>
  backendName: tbc-fc
  svm: openshift-fc
  sanType: fcp
  storagePrefix: demofc
  defaults:
    nameTemplate: "{{ .config.StoragePrefix }}_{{ .volume.Namespace }}_{{ .volume.RequestName }}"
  credentials:
    name: tbc-fc-secret
----
[source, yaml]
----
# cat sc-fc.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-fc
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
**Configuração Trident para cluster ROSA usando armazenamento FSxN**

.Backend Trident e classe de armazenamento para FSxN nas
[%collapsible%open]
====
[source, yaml]
----
#cat tbc-fsx-nas.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-fsx-ontap-nas-secret
  namespace: trident
type: Opaque
stringData:
  username: <cluster admin lif>
  password: <cluster admin passwd>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: backend-fsx-ontap-nas
  namespace: trident
spec:
  version: 1
  backendName: fsx-ontap
  storageDriverName: ontap-nas
  managementLIF: <Management DNS name>
  dataLIF: <NFS DNS name>
  svm: <SVM NAME>
  credentials:
    name: backend-fsx-ontap-nas-secret
----
[source, yaml]
----
# cat sc-fsx-nas.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: trident-csi
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-nas"
  fsType: "ext4"
allowVolumeExpansion: True
reclaimPolicy: Retain
----
====
.Backend Trident e classe de armazenamento para iSCSI FSxN
[%collapsible%open]
====
[source, yaml]
----
# cat tbc-fsx-iscsi.yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-tbc-fsx-iscsi-secret
type: Opaque
stringData:
  username: <cluster admin username>
  password: <cluster admin password>
---
apiVersion: trident.netapp.io/v1
kind: TridentBackendConfig
metadata:
  name: fsx-iscsi
spec:
  version: 1
  storageDriverName: ontap-san
  managementLIF: <management LIF>
  backendName: fsx-iscsi
  svm: <SVM name>
  credentials:
    name: backend-tbc-ontap-iscsi-secret
----
[source, yaml]
----
# cat sc-fsx-iscsi.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: sc-fsx-iscsi
provisioner: csi.trident.netapp.io
parameters:
  backendType: "ontap-san"
  media: "ssd"
  provisioningType: "thin"
  fsType: ext4
  snapshots: "true"
allowVolumeExpansion: true
----
====
**Classe Snapshot de volume Trident**

.Classe Snapshot de volume Trident
[%collapsible%open]
====
[source, yaml]
----
# cat snapshot-class.yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: trident-snapshotclass
driver: csi.trident.netapp.io
deletionPolicy: Retain
----
====
Depois que você tiver os arquivos yaml necessários para a configuração de back-end e a configuração da classe de armazenamento e as configurações de snapshot, você poderá criar os objetos backend do Trident , classe de armazenamento e classe de snapshot usando o seguinte comando

[source, yaml]
----
oc create -f <backend-filename.yaml> -n trident
oc create -f < storageclass-filename.yaml>
oc create -f <snapshotclass-filename.yaml>
----
**Padrões de configuração com armazenamento Trident e Classe de captura Instantânea**

.Configuração de padrões com armazenamento Trident e Classe de captura Instantânea
[%collapsible%open]
====
Agora você pode tornar a classe de armazenamento Trident necessária e a classe de snapshot de volume como padrão no cluster OpenShift. Como mencionado anteriormente, é necessário definir a classe de armazenamento e a classe de instantâneo de volume para permitir que o OpenShift Virtualization disponibilize a fonte de imagem dourada para criar vms a partir de modelos padrão.

Você pode definir a classe de armazenamento e a classe snapshot como padrão editando a anotação do console ou corrigindo a partir da linha de comando com o seguinte:

[source, yaml]
----
storageclass.kubernetes.io/is-default-class:true
or
kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

storageclass.kubevirt.io/is-default-virt-class: true
or
kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubevirt.io/is-default-virt-class": "true"}}}'
----
====